#' Calling of amplifications in low purity samples
#' 
#' Function to extract amplification from a
#' \code{\link{runAbsoluteCN}} return object in samples of too low purity
#' for the standard \code{link{callAlterations}}.
#' 
#' 
#' @param res Return object of the \code{\link{runAbsoluteCN}} function.
#' @param normalDB Normal database, created with
#' \code{\link{createNormalDatabase}}. 
#' @param pvalue.cutoff Copy numbers log-ratio cutoffs to call
#' amplifications as calculating using the log-ratios observed in
#' \code{normalDB}
#' @param percentile.cutoff Only report genes with log2-ratio mean
#' exceeding this sample-wise cutoff.
#' @param all.genes If \code{FALSE}, then only return amplifications
#' passing the thresholds. 
#' @return A \code{data.frame} with gene-level amplification calls.
#' @author Markus Riester
#' @seealso \code{\link{runAbsoluteCN}} \code{\link{callAlterations}}
#' @examples
#' 
#' data(purecn.example.output)
#' normal.coverage.file <- system.file("extdata", "example_normal.txt", 
#'     package="PureCN")
#' normal2.coverage.file <- system.file("extdata", "example_normal2.txt", 
#'     package="PureCN")
#' normal.coverage.files <- c(normal.coverage.file, normal2.coverage.file)
#' normalDB <- createNormalDatabase(normal.coverage.files)
#' callAmplificationsInLowPurity(purecn.example.output, normalDB)["EIF2A", ]
#' 
#' @importFrom stats ecdf pnorm
#' @export callAmplificationsInLowPurity
callAmplificationsInLowPurity <- function(res, normalDB,
pvalue.cutoff = 0.001, percentile.cutoff = 90, all.genes = FALSE) {

    if (percentile.cutoff < 0 || percentile.cutoff > 100) {
        .stopUserError("percentile.cutoff not in expected range (0 to 100).")
    }    
    if (!is(res$results[[1]]$gene.calls, "data.frame")) {
        .stopUserError("This function requires gene-level calls.\n",
            "Please add a column 'Gene' containing gene symbols to the ",
            "interval.file.")
    }
    if (is.null(normalDB$sd)) {
        .stopUserError("This function requires a normalDB object generated by PureCN 1.16 or later.")
    }    
    
    lrs_gr <- normalDB$sd$log.ratios  
    mcols(lrs_gr) <- apply(mcols(lrs_gr), 2, .calibrate_log_ratio, normalDB$sd$log.ratios)
    calls <- res$results[[1]]$gene.calls
    .get_gene_pv <- function(g) {
        # speed-up
        if (calls[g,]$gene.mean < 0) return(1) 
        g_gr <- GRanges(calls[g,])
        pon_lrs <- mcols(subsetByOverlaps(lrs_gr, g_gr))
        pon_w <- subsetByOverlaps(normalDB$sd$weights, g_gr)$weights
        pon_gene <- apply(pon_lrs, 2, weighted.mean, pon_w, na.rm = TRUE)
        pnorm(g_gr$gene.mean, mean = mean(pon_gene), sd = sd(pon_gene),
            lower.tail = FALSE)
    }

    calls$percentile <- ecdf(calls$gene.mean)(calls$gene.mean) * 100
    if (!all.genes) {
        calls <- calls[calls$percentile >= percentile.cutoff, ]
    }    
    calls$p.value <- sapply(rownames(calls), .get_gene_pv)
    calls$type <- NA
    amp.ids <- calls$p.value <= pvalue.cutoff & calls$percentile >= percentile.cutoff
    calls$type[amp.ids] <- "AMPLIFICATION"

    # delete columns not relevant for this algorithm
    calls <- calls[, !grepl("^\\.",colnames(calls))]
    calls$focal <- NULL
    calls$seg.mean <- NULL
    calls$seg.id <- NULL
    # support scaling of C in the future
    calls$C <- NA
       
    if (!all.genes) {
        return(calls[!is.na(calls$type),])
    }
    calls
}
